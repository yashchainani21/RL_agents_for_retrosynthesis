"""
Node abstractions for the DORAnet-guided Monte Carlo Tree Search.
"""

from __future__ import annotations

from typing import List, Optional

from rdkit import Chem


class Node:
    """
    Tree node storing an intermediate fragment generated by DORAnet.
    """

    node_counter = 0

    def __init__(
        self,
        fragment: Optional[Chem.Mol],
        parent: Optional["Node"] = None,
        depth: int = 0,
        provenance: Optional[str] = None,
        reaction_smarts: Optional[str] = None,
        reaction_name: Optional[str] = None,
        reactants_smiles: Optional[List[str]] = None,
        products_smiles: Optional[List[str]] = None,
    ) -> None:
        self.fragment: Optional[Chem.Mol] = fragment
        self.parent: Optional["Node"] = parent
        self.children: List["Node"] = []
        self.depth: int = depth
        self.provenance: Optional[str] = provenance  # tracks enzymatic vs synthetic

        # Reaction information that created this fragment
        self.reaction_smarts: Optional[str] = reaction_smarts
        self.reaction_name: Optional[str] = reaction_name
        self.reactants_smiles: Optional[List[str]] = reactants_smiles or []
        self.products_smiles: Optional[List[str]] = products_smiles or []

        # MCTS bookkeeping
        self.visits: int = 0
        self.value: float = 0.0
        self.selection_score: Optional[float] = None
        self.expanded: bool = False

        # Iteration tracking for visualization
        self.created_at_iteration: Optional[int] = None
        self.selected_at_iterations: List[int] = []
        self.expanded_at_iteration: Optional[int] = None

        # Sink compound flag - indicates commercially available building blocks
        # that don't need further expansion
        self.is_sink_compound: bool = False
        # Type of sink compound: "biological", "chemical", or None
        self.sink_compound_type: Optional[str] = None

        # PKS terminal flag - indicates fragments that match the PKS library
        # and can be synthesized by polyketide synthases (don't need further expansion)
        self.is_pks_terminal: bool = False

        # identifiers for logging/visualizing the tree
        self.node_id: int = Node.node_counter
        self.parent_id: Optional[int] = parent.node_id if parent else None
        Node.node_counter += 1

    @property
    def smiles(self) -> Optional[str]:
        return Chem.MolToSmiles(self.fragment) if self.fragment is not None else None

    def add_child(self, child: "Node") -> None:
        if child not in self.children:
            if child.parent is None:
                child.parent = self
            child.depth = self.depth + 1
            self.children.append(child)

    def update(self, reward: float) -> None:
        self.value += reward
        self.visits += 1

    def __repr__(self) -> str:
        terminal_str = ""
        if self.is_sink_compound:
            terminal_str = f", sink={self.sink_compound_type or 'True'}"
        elif self.is_pks_terminal:
            terminal_str = ", pks_terminal=True"
        return (
            f"Node(id={self.node_id}, depth={self.depth}, "
            f"smiles={self.smiles}, provenance={self.provenance}, "
            f"visits={self.visits}, value={self.value:.3f}{terminal_str})"
        )

