"""
Node abstractions for the DORAnet-guided Monte Carlo Tree Search.
"""

from __future__ import annotations

from typing import List, Optional

from rdkit import Chem


class Node:
    """
    Tree node storing an intermediate fragment generated by DORAnet.
    """

    node_counter = 0

    def __init__(
        self,
        fragment: Optional[Chem.Mol],
        parent: Optional["Node"] = None,
        depth: int = 0,
        provenance: Optional[str] = None,
        reaction_smarts: Optional[str] = None,
        reaction_name: Optional[str] = None,
        reactants_smiles: Optional[List[str]] = None,
        products_smiles: Optional[List[str]] = None,
    ) -> None:
        self.fragment: Optional[Chem.Mol] = fragment
        self.parent: Optional["Node"] = parent
        self.children: List["Node"] = []
        self.depth: int = depth
        self.provenance: Optional[str] = provenance  # tracks enzymatic vs synthetic

        # Reaction information that created this fragment
        self.reaction_smarts: Optional[str] = reaction_smarts
        self.reaction_name: Optional[str] = reaction_name
        self.reactants_smiles: Optional[List[str]] = reactants_smiles or []
        self.products_smiles: Optional[List[str]] = products_smiles or []

        # MCTS bookkeeping
        self.visits: int = 0
        self.value: float = 0.0
        self.selection_score: Optional[float] = None
        self.expanded: bool = False

        # Iteration tracking for visualization
        self.created_at_iteration: Optional[int] = None
        self.selected_at_iterations: List[int] = []
        self.expanded_at_iteration: Optional[int] = None

        # Sink compound flag - indicates commercially available building blocks
        # that don't need further expansion
        self.is_sink_compound: bool = False
        # Type of sink compound: "biological", "chemical", or None
        self.sink_compound_type: Optional[str] = None

        # PKS terminal flag - indicates fragments that match the PKS library
        # and can be synthesized by polyketide synthases (don't need further expansion)
        self.is_pks_terminal: bool = False

        # identifiers for logging/visualizing the tree
        self.node_id: int = Node.node_counter
        self.parent_id: Optional[int] = parent.node_id if parent else None
        Node.node_counter += 1

    @property
    def smiles(self) -> Optional[str]:
        return Chem.MolToSmiles(self.fragment) if self.fragment is not None else None

    def add_child(self, child: "Node") -> None:
        if child not in self.children:
            if child.parent is None:
                child.parent = self
            child.depth = self.depth + 1
            self.children.append(child)

    def update(self, reward: float) -> None:
        self.value += reward
        self.visits += 1

    def apply_virtual_loss(self, virtual_loss: float = 1.0) -> None:
        """
        Apply virtual loss to discourage parallel thread selection.

        This temporarily penalizes the node's statistics to make it appear
        less attractive to other threads during parallel MCTS. The virtual
        loss should be removed after expansion completes.

        Args:
            virtual_loss: The penalty value to subtract from node value.
        """
        self.visits += 1
        self.value -= virtual_loss

    def remove_virtual_loss(self, virtual_loss: float = 1.0) -> None:
        """
        Remove virtual loss after expansion completes.

        This restores the node's statistics by reversing the virtual loss
        penalty, preparing the node for real reward backpropagation.

        Args:
            virtual_loss: The penalty value that was previously applied.
        """
        self.visits -= 1
        self.value += virtual_loss

    def __repr__(self) -> str:
        terminal_str = ""
        if self.is_sink_compound:
            terminal_str = f", sink={self.sink_compound_type or 'True'}"
        elif self.is_pks_terminal:
            terminal_str = ", pks_terminal=True"
        return (
            f"Node(id={self.node_id}, depth={self.depth}, "
            f"smiles={self.smiles}, provenance={self.provenance}, "
            f"visits={self.visits}, value={self.value:.3f}{terminal_str})"
        )

