"""
This script is used to enumerate all possible PKS products that can be generated by a chimeric type I PKS.
Chimeric PKSs were designed with RetroTide and vary in both the number of modules and domain architectures involved.
The smallest PKS designed comprises only a loading module while the largest PKS comprises three extension modules.

"""
import bcs
from retrotide import retrotide, structureDB
from rdkit import Chem
from rdkit.Chem import AllChem
from collections import OrderedDict

def _pks_release_reaction(pks_release_mechanism: str,
                          bound_product_mol: Chem.Mol) -> Chem.Mol:
    """
    Run an offloading reaction to release a bound PKS product.
    Two types of offloading reactions are currently supported: thiolysis and cyclization.
    A thiolysis offloading reaction will result in the formation of a carboxylic acid.
    Meanwhile, a cyclization offloading reaction results in the formation of a lactone ring.
    """

    if pks_release_mechanism == 'thiolysis':
        Chem.SanitizeMol(bound_product_mol)  # run detachment reaction to produce terminal acid group
        rxn = AllChem.ReactionFromSmarts('[C:1](=[O:2])[S:3]>>[C:1](=[O:2])[O].[S:3]')
        unbound_product_mol = rxn.RunReactants((bound_product_mol,))[0][0]
        Chem.SanitizeMol(unbound_product_mol)
        return unbound_product_mol

    if pks_release_mechanism == 'cyclization':
        Chem.SanitizeMol(bound_product_mol)  # run detachment reaction to cyclize bound substrate
        rxn = AllChem.ReactionFromSmarts('([C:1](=[O:2])[S:3].[O,N:4][C:5][C:6])>>[C:1](=[O:2])[*:4][C:5][C:6].[S:3]')
        try:
            unbound_product_mol = rxn.RunReactants((bound_product_mol,))[0][0]
            Chem.SanitizeMol(unbound_product_mol)
            return unbound_product_mol

        # if the bound substrate cannot be cyclized, then return None
        except:
            raise ValueError("\nUnable to perform cyclization reaction")

all_starters_list = list(bcs.starters.keys())
all_extenders_list = list(bcs.extenders.keys())

# initialize an empty dictionary to store all bcs-type PKS designs as keys and PKS products as values
all_PKS_designs_and_products_dict = {}

# iterate through all starter units
for starter in all_starters_list:

    # initialize a list to store all bcs.Module objects
    all_bcs_modules_list = []

    # initialize a PKS loading module for the current PKS starter
    loading_AT_domain = bcs.AT(active = True,
                               substrate = starter)

    loading_module = bcs.Module(domains = OrderedDict({bcs.AT: loading_AT_domain}),
                                loading = True)

    all_bcs_modules_list.append(loading_module)

    # convert this loading module into a bcs cluster object and obtain the corresponding product
    bound_LM_product = bcs.Cluster(modules = all_bcs_modules_list).computeProduct(structureDB)

    all_PKS_designs_and_products_dict.update({loading_module: bound_LM_product})

    # then, iterate through each extender unit for each extension module
    for extender in all_extenders_list:

        # initialize the extension AT domain
        extension_AT_domain = bcs.AT(active = True, substrate = extender)

        # with this extension AT, build the simplest PKS involving only the KS, AT, & ACP domains
        KS_AT_ACP_domains_dict = OrderedDict({bcs.AT: extension_AT_domain})
        KS_AT_ACP_extension_module = bcs.Module(domains = KS_AT_ACP_domains_dict,
                                                loading = False)

        all_bcs_modules_list.append(KS_AT_ACP_extension_module)

        KS_AT_ACP_module = bcs.Cluster(modules = all_bcs_modules_list)
        KS_AT_ACP_product = KS_AT_ACP_module.computeProduct(structureDB)

        # then, create an empty list to store all KR domain types to use with this extender unit
        KR_domain_types_available = []

        all_KR_domain_types = ['A1', 'A2', 'A', 'B1', 'B2', 'B', 'C1', 'C2']
        KR_domain_types_for_malonyl_CoA = ['A','B']
        KR_domain_types_for_methylmalonyl_CoA = ['A1', 'A2', 'B1', 'B2', 'C1', 'C2']

        if extender == 'Malonyl-CoA':
            KR_domain_types_available += KR_domain_types_for_malonyl_CoA

        if extender == 'Methylmalonyl-CoA':
            KR_domain_types_available += KR_domain_types_for_methylmalonyl_CoA

        else:
            KR_domain_types_available += all_KR_domain_types

        for KR_domain_type in KR_domain_types_available:
            KR_domain = bcs.Module(domains = OrderedDict({bcs.AT: extension_AT_domain,
                                                          bcs.KR: bcs.KR(active = True,
                                                                         type = KR_domain_type)}))
